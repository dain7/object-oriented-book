# 챕터 06: 객체 지도

## 📚 핵심 내용 요약

길을 모른다고 가정할 때 길을 찾는 두가지 방법 존재

- 길을 묻는 방법
- 지도를 보는 방법

길을 묻는 방법은 현재의 마을에서 다른 마을로 이동하는 현재의 요구만을 만족시킬 수 있다. 이에 반해 지도는 현재의 목적 뿐만 아니라 다양한 목적을 위해 재사용될 수 있다.
지도가 범용적인 이유는 지도를 사용하려는 사람들이 원하는 '기능'에 비해 지도에 표시된 '구조가 더 안정적이기 때문이다.
기능에 대한 요구사항이 계속 변함에도 지도는 모든 요구사항을 수용할 수 있다. 지도는 기능에 비해 상대적으로 잘 변하지 않는 안정적인 지형 정보를 기반으로 하고 있기 때문이다.

지도 은유의 핵심은 기능이 아니라 구조를 기반으로 모델을 구축하는 것이 더 범용적이고 이해하기 쉬우며 변경에 안정적이라는 것.
기능을 중심으로 구조를 종속시키는 접근법은 범용적이지 않고 재사용이 불가능하며 변경에 취약한 모델을 낳게 된다. 이와 달리 안정적인 구조를 중심으로 기능을 종속시키는 접근법은 범용적이며 재사용 가능하며 변경에 유연하게 대처할 수 있는 모델을 만든다.

객체지향 개발 방법은 안정적인 구조에 변경이 빈번하게 발생하는 기능을 종속시키는 지도의 방법과 유사하다. 이것이 객체지향의 과거의 전통적인 방법보다 범용적이고, 재사용성이 높으며, 변경에 안정적인 이유다.

객체지향은 자주 변경되는 기능이 아니라 안정적인 구조를 기반으로 시스템을 구조화한다.

### 기능 설계 대 구조 설계

모든 소프트웨어 제품의 설계에는 두 가지 측면이 존재한다. 하나는 기능이고, 하나는 구조다.

- 기능: 제품이 사용자를 위해 무엇을 할 수 있는가
- 구조: 제품의 형태가 어떠해야 하는가

소프트웨어 개발 초기 단계에서는 사용자가 무엇을 원하는지, 그리고 사용자가 원하는 것을 만족시키기 위해 시스템이 어떤 기능을 제공해야 하는지에 대해 초점을 맞춰야 한다.
그러나 요구사항을 계속 변경됨 => 여기에 대비하는 방법은 변경을 수용할 수 있는 여지를 설계에 마련해 놓는 것 => 안정적인 구조를 중심으로 설계하는 것이다.

- 기능 분해: 자주 변경되는 기능 중심 설계 -> 구조가 기능을 따름 -> 기능 변경시 전체적인 소프트웨어가 요동침
- 객체 지향: 안정적인 객체 구조 기반으로 시스템 기능을 객체 간의 책임으로 분배 -> 기능 변경되더라도 객체 구조는 유지

### 기능과 구조

- 유스케이스 모델링: 기능을 수집하고 표현하기 위한 기법 => 유스케이스
- 도메인 모델링: 구조를 수집하고 표현하기 위한 기법 => 도메인 모델

##### 도메인 모델

- 소프트웨어를 사용하는 사람들은 자신이 관심을 가지고 있는 특정한 분야의 문제를 해결하기 위해 소프트웨어를 사용한다.
  이처럼 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다.
- 모델은 중요한 문제에 집중할 수 있도록 필요한 지식만 재구성한 것이다 => 대상을 추상화하고 단순화한 것

**도메인 모델**이란 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 것.
FYI. 멘탈모델: 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형
제품을 설계할 때 제품에 관한 모든 것이 사용자들이 제품에 대해 가지고 있는 멘탈 모델과 정확히 일치애햐 한다. 사용자들은 자신의 멘탈 모델과 유사한 방식으로 제품이 반응하고 움직일 것이라 기대하기 때문에.
최종 코드는 사용자가 도메인을 바라보는 관점을 반영해야 함 => 애플리케이션은 도메인 모델을 기반으로 설계돼야 한다.

사용자들은 누구보다도 도메인의 '본질적인' 측면을 가장 잘 이해하고 있다. 본질적이라는 것은 변경이 적고 특성이 오랜 시간 유지되는 것. 소프트웨어 개발의 가장 큰 적은 변경임. 도메인 모델은 안정적인 구조를 제공할 수 있음 (변경에 유연한)

### 기능

시스템이 사용자에게 기능을 제공하는 이유는? -> 사용자들이 시스템을 통해 달성하고자 하는 '목표'가 존재하기 때문임.
사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것을 **유스케이스**라고 함.

##### 유스케이스의 특성

1. 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다. 유스케이스의 핵심은 사용자와 시스템 간의 상호작용을 일련의 이야기 흐름으로 표현하는 것.

2. 유스케이스는 하나의 시나리오가 아니라 여러 시나리오들의 집합이다. 시나리오는 유스케이스를 통해 시스템을 사용하는 하나의 특정한 이야기 또는 경로다.
   이자 계산 유스케이스는 2개의 시나리오를 포함한다.

- 예금주가 계좌를 선택하고 당일까지의 이자액을 계산하는 것.
- 예금주가 계좌를 선택하고 특정일자까지의 이자액을 계산하는 것

3. 유스케이스는 단순한 피처 목록과 다르다. 피처는 시스템이 수행해야 하는 기능의 목록을 단순히 나열한 것.
   예를 들어 '시스템은 정기예금 정보를 보여준다', '시스템은 당일이나 현재 일자의 이자를 계산한다' 등등
   피처의 단점은 이 두 피처를 서로 연관이 없는 독립적인 기능으로 보이게끔 만든다는 것이다. -> 유스케이스는 이야기를 통해 연관된 기능들을 함께 묶을 수 있음

4. 유스케이스는 사용자 인터페이스와 관련된 세부 정보를 포함하지 말아야 한다.

5. 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다. 유스케이스의 목적은 연관된 시스템의 기능을 이야기 형식으로 모으는 것이지 내부 설계를 설명하는 것은 아님.

##### 유스케이스는 설계 기법도, 객체 지향 기법도 아니다.

유스케이스는 단지 사용자가 바라보는 시스템의 외부 관점만을 표현한다. 유스케이스는 객체의 구조나 책임에 대한 어떤 정보도 제공하지 않는다.

### 기능과 구조의 통합

불안정한 기능을 안정적인 구조 안에 담음으로써 변경에 대한 파급효과를 최소하하는 것은 훌륭한 객체지향 설계자가 갖춰야 할 기본적인 설계 능력이다. 도메인 모델은 안정적인 구조를 개념화하기 위해, 유스케이스는 불안정한 기능을 서술하기 위해 가장 일반적으로 사용되는 도구다!

시스템의 기능을 책임으로 바꾼다 => 책임은 시스템 안의 객체들이 수행해야 하는 더 작은 규모의 책임으로 세분화된다 => 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택한다

책임 할당의 기본 원칙은 책임을 수행하는데 필요한 정보를 가진 객체에게 그 책임을 할당하는 것.
유스케이스에서 출발홰 객체들의 협력으로 이어지는 일련의 흐름은 객체 안에 다른 객체를 포함하는 재귀적 합성이라는 객체지향의 기본 개념을 잘 보여준다.

**사람들이 동일한 용어와 동일한 개념을 이용해 의사소통하고 코드로부터 도메인 모델을 유추할 수 있게 하는 것이 도메인 모델의 진정한 목표다**

## 🤔 내 생각 및 질문

1. 기능 기반, 구조 기반 각각의 모델의 예시와 장단점
   **기능 기반**
   전통적인 3계층 아키텍처:
   Controller → Service → Repository

✅ 장점
역할이 명확해서 초기에 빠르게 개발 가능
구조가 단순해서 초심자에게 익숙
대부분의 CRUD 업무에 적합

❌ 단점
도메인 개념이 코드에서 흩어져 있어서 파악하기 어려움
규모가 커지면 서비스가 비대해지고, 관련 코드가 여러 모듈에 흩어짐
비즈니스 규칙의 재사용과 테스트가 어려움

**구조 기반**
도메인 단위로 폴더 구조와 책임을 분리

✅ 장점
도메인 중심으로 설계되어 변화에 강하고 유지보수 쉬움
비즈니스 로직이 응집도 높게 모여 있음
테스트와 재사용성이 뛰어남

❌ 단점
도메인 이해와 설계에 시간이 많이 듦
초기에 복잡하고, 잘못 설계하면 오히려 독이 됨
작은 프로젝트에는 과한 설계일 수 있음

2. 도메인 모델이 잘 변하지 않기 때문에 안정적인 시스템을 구축할 수 있다고 했는데, 도메인 모델 기반으로 시스템을 구축하지 않더라도 대부분의 시스템 구성이 잘 변하지 않지 않나? 잘 변하는 예시?

❗기능 기반 구조에서 문제가 드러나는 변화 예시

- 요금 계산 로직이 바뀌는 경우
  예: 상품에 따라 수수료율이 다르게 적용
  서비스 레이어에 여러 if-else가 추가됨 → 점점 복잡도 증가

- 국가별 정책 변경
  예: 한국은 A 방식, 베트남은 B 방식
  기능 기반으로 되어있다면 조건문 난무 + 구조가 분산됨

- 결제 수단 추가
  예: 기존에는 카드만 지원했는데, 이제는 간편결제, 가상계좌도 필요
  도메인 기반이면 PaymentMethod 같은 개념이 도메인 단위로 잘 정의되어 있어 재사용성 좋음
  기능 기반이면 서비스 로직이 지저분하게 얽힘

- B2B 고객사마다 요구 사항이 다름
  예: A사는 필수 필드 3개, B사는 5개
  도메인 기반이면 전략 패턴이나 Validator 체인 등으로 분리 설계가 수월

## 💡 적용 및 실천 아이디어

“견적 생성”이라는 유즈케이스에 “이관견적 / 송금견적”이라는 도메인 타입이 있고, 그 안에 “수수료 계산”이라는 핵심 피처가 있다면?

-Use Case: 견적을 생성한다 (CreateQuotation)

- 피처: 수수료를 계산한다 (CalculateFee)

```kotlin
interface Quotation {
    fun calculateFee(): Fee
}

class TransferQuotation(
    val amount: BigDecimal,
    val feePolicy: FeePolicy
) : Quotation {
    override fun calculateFee(): Fee {
        return feePolicy.calculate(amount)
    }
}

class RemittanceQuotation(
    val amount: BigDecimal,
    val feePolicy: FeePolicy
) : Quotation {
    override fun calculateFee(): Fee {
        return feePolicy.calculate(amount)
    }
}

interface FeePolicy {
    fun calculate(amount: BigDecimal): Fee
}

class QuotationService {
    fun createQuotation(request: QuotationRequest): QuotationResponse {
        val feePolicy = selectFeePolicy(request.type)
        val quotation = when (request.type) {
            QuotationType.TRANSFER -> TransferQuotation(request.amount, feePolicy)
            QuotationType.REMITTANCE -> RemittanceQuotation(request.amount, feePolicy)
        }

        val fee = quotation.calculateFee()
        return QuotationResponse.of(quotation, fee)
    }

    private fun selectFeePolicy(type: QuotationType): FeePolicy {
        return when (type) {
            QuotationType.TRANSFER -> TransferFeePolicy()
            QuotationType.REMITTANCE -> RemittanceFeePolicy()
        }
    }
}
```
